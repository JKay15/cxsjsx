参考文件地址https://github.com/danprince/norman-the-necromancer

DEVLOG文件是按时间顺序的开发流程


action文件定义了四个函数，包括 Damage，Die，Cast 和 Resurrect。
Damage 函数接受三个参数：一个游戏对象，一个伤害量和一个可选的伤害来源。这个函数会调用游戏对象的 onDamage 方法，并减少游戏对象的生命值。如果游戏对象的生命值降为零，则调用 Die 函数。
Die 函数接受两个参数：一个游戏对象和一个可选的杀手。这个函数会创建一个 Death 对象，并根据游戏对象是否具有 MOBILE 标签执行不同的操作。如果游戏对象具有 MOBILE 标签，则会在游戏中生成骨头特效和尸体，并增加游戏中的灵魂数量。最后，这个函数会调用游戏对象的 onDeath 方法，并将其从游戏中移除。
Cast 函数会根据当前选择的法术进行施法。它会减少法术的剩余施法次数，并更改玩家角色的精灵图像。然后，它会根据法术的基础威力、目标角度和每轮发射数量生成多个投射物。最后，它会调用游戏的 onCast 方法。
Resurrect 函数会复活所有尸体。它首先检查能力是否处于冷却状态。如果不处于冷却状态，则重置能力计时器，并调用所有仪式对象的 onResurrect 方法。然后，它会遍历所有尸体对象，将其从游戏中移除，并在其位置生成一个骷髅单位。最后，它会调用所有仪式对象的 onResurrection 方法。


那个objects文件可以先不用看，全是独立的角色设计

engine文件是管画面绘制的，可以先不用管
他定义了一些用于渲染游戏画面的函数和类型，包括 `Sprite`，`Rect`，`clear`，`drawSprite`，`drawSceneSprite`, `drawSpriteSlice`, `drawNineSlice`, `write`, `init`, `linear`, `updateTweens`, `tween`, `Range`, `randomFromRange`, `particleEmitters`, `Particle`, 和 `ParticleEmitter`.

- `Sprite`: 这个类型定义了一个精灵图像。它是一个包含四个数字的数组，分别表示精灵图像在源图像中的位置和大小。
- `Rect`: 这个接口定义了一个矩形。它具有四个属性：x、y、w和h。
- `clear`: 这个函数用于清除画布。
- `drawSprite`: 这个函数用于绘制一个精灵图像。它接受一个精灵图像和两个坐标参数，表示精灵图像在画布上的位置。
- `drawSceneSprite`: 这个函数用于绘制一个场景精灵图像。它接受一个精灵图像和两个坐标参数，表示精灵图像在场景中的位置。它会将精灵图像的底部左侧对齐到指定的坐标，并将y坐标视为负数，以便正数y值看起来会将精灵图像向上移动。
- `drawSpriteSlice`: 这个函数用于绘制一个精灵图像的一部分。它接受八个参数，分别表示源图像中的位置和大小、目标画布中的位置和大小。
- `drawNineSlice`: 这个函数用于绘制一个九宫格精灵图像。它接受五个参数，分别表示精灵图像、目标画布中的位置和大小。
- `write`: 这个函数用于在画布上绘制一段文本。它接受一个文本字符串和两个可选的坐标参数，表示文本在画布上的位置。
- `init`: 这个函数用于初始化游戏。它接受三个参数，分别表示画布的宽度、高度和更新函数。它会设置画布的大小，并启动游戏循环。
- `linear`: 这个函数是一个线性缓动函数。它返回输入值本身。
- `updateTweens`: 这个函数用于更新所有补间动画。它接受一个时间差参数，并更新所有补间动画的进度。如果补间动画已经完成，则从补间动画列表中删除它。
- `tween`: 这个函数用于创建一个新的补间动画。它接受五个参数，分别表示起始值、结束值、持续时间、回调函数和缓动函数。它会创建一个新的补间动画对象，并将其添加到补间动画列表中。
- `Range`: 这个类型定义了一个范围。它是一个包含两个数字的数组，分别表示范围的基础值和扩展值。
- `randomFromRange`: 这个函数用于从指定范围内随机生成一个数字。它接受一个范围参数，并返回一个随机数。
- `particleEmitters`: 这是一个包含所有粒子发射器对象的数组。
- `Particle`: 这个接口定义了一个粒子对象。它具有一些属性，包括位置、速度、弹性、持续时间、变化率、质量和摩擦系数等。
- `ParticleEmitter`: 这个类定义了一个粒子发射器对象。它具有一些属性和方法，用于管理粒子发射器的位置、大小、发射频率、速度范围、角度范围、持续时间范围等信息。它还可以更新粒子发射器中所有粒子的状态，并发射新的粒子。

fx.json文件定义了一些用于生成粒子效果的函数，包括 bones，trail，cloud，royalty，dust, 和 resurrect.
bones: 这个函数创建一个新的粒子发射器，并设置一些属性。它的持续时间为10秒到15秒，摩擦系数为0.6，速度为5到25，角度为90度左右，弹性为0.1到0.6，质量为60，并且具有三种不同的骨头精灵图像。
trail: 这个函数创建一个新的粒子发射器，并设置一些属性。它的持续时间为0.5秒到1.5秒，速度为1到11，角度为180度左右，弹性为0，发射频率为2，质量为3，并且具有三种不同的绿色精灵图像。
cloud: 这个函数接受一个矩形区域和一组精灵图像作为参数，并创建一个新的粒子发射器。它将发射器的位置和大小设置为指定的矩形区域，并设置一些其他属性。它的持续时间为0.5秒到1.5秒，速度为1到11，角度为90度左右，弹性为0，发射频率为2，质量为-2，并且具有指定的精灵图像。
royalty: 这个函数创建一个新的粒子发射器，并扩展 trail 函数返回的粒子发射器。它将发射频率设置为0.5，并将精灵图像设置为三种不同的星星图像。
dust: 这个函数创建一个新的粒子发射器，并设置一些属性。它将发射器的位置和大小设置为整个游戏舞台，并设置一些其他属性。它的角度范围是360度，持续时间为5秒到15秒，速度为1到4，弹性为0，发射频率为0.1，并且具有两种不同的灰尘精灵图像。
resurrect: 这个函数接受一个游戏对象作为参数，并创建一个新的粒子发射器。它扩展了 cloud 函数返回的粒子发射器，并将其位置和大小设置为指定游戏对象的边界。它还将发射频率设置为0，并将精灵图像设置为三种不同的绿色图像。


game.ts定义了一些游戏相关的类和类型，包括 Rarity，COMMON，RARE，GameObject，Behaviour，Damage，Death，Stage，Spell，Ability，Ritual, INTRO, PLAYING, SHOPPING, LOSE, WIN, State, ShopItem, 和 Game.

Rarity: 这个类型定义了物品的稀有度，它可以是 COMMON 或者 RARE.
COMMON: 这个常量表示物品的稀有度为普通。
RARE: 这个常量表示物品的稀有度为稀有。
GameObject: 这个类定义了一个游戏对象。它具有一些物理属性、显示属性、逻辑属性和行为属性。它还定义了一些方法，用于更新游戏对象、添加和移除行为、获取行为、处理碰撞和弹跳等。
Behaviour: 这个类定义了一个游戏对象的行为。它具有一个游戏对象属性、一个持续时间属性、一个计时器属性和一个精灵图像属性。它还定义了一些生命周期方法和事件处理方法。
Damage: 这个接口定义了一个伤害对象。它具有一个伤害量属性和一个伤害来源属性。
Death: 这个接口定义了一个死亡对象。它具有一个游戏对象属性、一个杀手属性和一个灵魂数量属性。
Stage: 这个接口定义了一个游戏舞台。它具有四个属性：宽度、高度、地面高度和天花板高度。
Spell: 这个接口定义了一个法术。它具有一些属性，包括目标角度、目标半径、基础威力、每回合发射次数、发射角度偏移量、最大施法次数、施法次数、施法充能速率和施法充能计时器。
Ability: 这个接口定义了一个能力。它具有两个属性：冷却时间和计时器。
Ritual: 这个接口定义了一个仪式。它具有一些属性和方法，包括名称、描述、标签、排他性标签、必需标签、是否递归、稀有度等。它还可以定义一些事件处理方法，用于在游戏中的不同阶段执行特定操作。
INTRO: 这个常量表示游戏状态为介绍。
PLAYING: 这个常量表示游戏状态为进行中。
SHOPPING: 这个常量表示游戏状态为购物中。
LOSE: 这个常量表示游戏状态为失败。
WIN: 这个常量表示游戏状态为胜利。
State: 这个类型定义了游戏状态，它可以是上述五种状态之一。
ShopItem: 这个接口定义了一个商店物品。它具有四个属性：花费、名称、描述和购买函数。这个函数用于创建一个新的商店物品。
Game: 这个类定义了一个游戏。它具有一些属性和方法，用于管理游戏舞台、游戏对象、仪式、状态、灵魂数量等信息。它还可以更新游戏中的各种信息，并处理各种事件。


helpers.ts定义了一些用于游戏开发的辅助函数和类型

index.ts定义了游戏的主要逻辑，包括初始化游戏、处理用户输入、更新游戏状态和渲染游戏画面。

首先，它创建了一个 Player 对象，并将其精灵图像设置为骷髅图像。
然后，它创建了一个新的 Game 对象，并将玩家对象传递给它。
接下来，它定义了一些常量，用于表示不同的按键代码。
然后，它定义了一些对话文本，用于在游戏的不同阶段显示给玩家。
接下来，它定义了一些事件处理函数，用于处理用户的鼠标和键盘输入。当用户点击鼠标时，如果游戏状态为 INTRO，则播放音效并将游戏状态设置为 PLAYING；否则执行 Cast 函数。当用户移动鼠标时，更新法术的目标角度。当用户按下键盘时，根据按键执行不同的操作。
然后，它定义了一个变量 normanIsBouncing，用于记录玩家是否正在弹跳。
接下来，它定义了一个 update 函数，用于更新游戏状态。这个函数首先调用 updateDialogue 和 render 函数；然后根据游戏状态执行不同的操作。如果游戏状态为 PLAYING，则调用 updateLevel 函数；如果游戏状态不为 INTRO，则调用 game.update 函数。最后调用 updateTweens 和 updateParticles 函数。
然后，它定义了一个 onWin 函数，用于处理玩家胜利的情况。这个函数将游戏状态设置为 WIN 并更新对话文本。
接下来，它定义了一个变量 dialogueTimer 和一个函数 updateDialogue。这个函数用于更新对话文本的显示时间。如果对话计时器超过4秒，则从对话文本中删除第一条文本并重置计时器。如果玩家观看了整个对话，则在对话文本中添加一条提示信息。
最后，它调用 init 函数初始化游戏，并调用 dust().burst(200) 生成一些粒子效果。


ritual.ts定义了一些游戏中的仪式，包括 Streak，Bouncing，Doubleshot，Hunter，Weightless，Knockback，Ceiling，Rain, Drunkard, Seer, Tearstone, Impatience, Bleed, Allegiance, Salvage, Studious, Electrodynamics, Chilly, Giants, Avarice, 和 Hardened.

每个仪式都是一个对象，具有一些属性和方法。
它们的名称和描述属性用于在游戏中显示给玩家。
它们的标签属性用于表示仪式的类型。
它们还可以定义一些事件处理方法，用于在游戏中的不同阶段执行特定操作。
例如：

Streak: 这个仪式在施法时会给法术添加一个 HitStreak 行为。
Bouncing: 这个仪式在施法时会给法术添加一个弹跳效果。它会设置法术的消失计时器、弹性和弹跳标志。
Doubleshot: 这个仪式是稀有的，并且与其他分裂仪式互斥。它会将游戏中每回合发射的法术数量设置为2。
Hunter: 这个仪式是稀有的。它在施法时会给法术添加一个寻找目标的行为。
Weightless: 这个仪式在施法时会将法术的质量、摩擦系数和弹性设置为0。
如果你想仿照这个游戏写一个几乎一样的游戏，你可以按照以下步骤进行：

1. 首先，你需要了解这个游戏的基本结构和运行逻辑。这包括游戏中的类和函数，以及它们之间的关系和作用。

2. 其次，你需要准备好游戏所需的资源，包括精灵图像、字体、音效等。

3. 然后，你可以开始编写游戏代码。首先，你需要定义游戏中的基础类，如 `GameObject`，`Behaviour` 和 `Game` 类。然后，你可以根据需要定义一些继承自这些类的子类，用于实现游戏中的具体对象和行为。

4. 接下来，你需要编写游戏的渲染代码。这包括用于绘制精灵、文本和粒子效果的函数，以及用于创建不同类型的粒子效果的函数。

5. 最后，你需要编写游戏的主循环和更新逻辑。这包括处理用户输入、更新游戏状态、检测碰撞和渲染画面等。

以上只是一个简单的概述，具体的实现细节还需要根据你自己的需求进行调整。
